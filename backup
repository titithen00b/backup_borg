#!/bin/bash
set -euo pipefail

# Exécution minimale en root
if [ "$(id -u)" -ne 0 ]; then
    echo "Ce script doit être lancé en root" >&2
    exit 1
fi

trap 'log_message "Interruption — nettoyage"; umount_NAS; exit 2' INT TERM EXIT

#######################
# Variables à configurer
#######################
SHOW_HELP=false

SOURCE_DIR="/"                # Répertoire source à sauvegarder
DEST_DIR="/var/backup"        # Répertoire où seront stockées les sauvegardes Borg
MOUNT_POINT="/var/backup"
NAS_SERVER=""                 # exemple: 192.168.1.100
CONFIG_FILE="/etc/backup_script/smb.conf"  # fichier credentials CIFS
BORG_PASS_FILE="/etc/backup_script/borg_pass" # fichier contenant le mot de passe borg (optionnel)

# Si le fichier BORG_PASS_FILE existe, on le lit
BORG_PASSPHRASE=""
if [ -r "$BORG_PASS_FILE" ]; then
    BORG_PASSPHRASE="$(cat "$BORG_PASS_FILE")"
    export BORG_PASSPHRASE
fi

DOCKER="1"                    # 1 = sauvegarde Docker activée, 0 = désactivée
BACKUP_DOCKER="/var/backups/docker" # Répertoire des sauvegardes Docker
NAME_FOR_NOTIFY="Serveur"     # Nom qui apparaîtra dans les notifications

# Free Mobile (notifications SMS)
FREE_MOBILE_USER=""
FREE_MOBILE_CODE_AUTH=""
PHONE_NUMBER=""

# Etats / flags
backup_success=0
mount_success=0
umount_success=0
backup_docker_flag=0

# Options
EXCLUDES=""

#######################
# Fonctions utilitaires
#######################

log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> /var/log/backup.log
}

send_sms_notification() {
    local message="$1"
    echo "$message"
    if [ -n "$FREE_MOBILE_USER" ] && [ -n "$FREE_MOBILE_CODE_AUTH" ]; then
        curl -s -k --get --data-urlencode "msg=$message" \
            "https://smsapi.free-mobile.fr/sendmsg?user=$FREE_MOBILE_USER&pass=$FREE_MOBILE_CODE_AUTH" >/dev/null 2>&1 || {
                log_message "Erreur envoi SMS (curl) pour : $message"
            }
    else
        log_message "Envoi SMS désactivé (identifiants Free Mobile manquants) : $message"
    fi
}

show_help() {
cat << EOF
=========================================
        SCRIPT DE SAUVEGARDE BORG
=========================================

Usage :
  sudo /usr/local/bin/backup [options]

Options disponibles :
  -h, -?        Affiche cette aide et quitte

Variables importantes à configurer dans le script :
  SOURCE_DIR          : Répertoire source à sauvegarder (ex: "/")
  DEST_DIR            : Répertoire de destination pour Borg (ex: "/var/backup")
  MOUNT_POINT         : Point de montage local pour le NAS
  NAS_SERVER          : Adresse IP ou nom du NAS (ex: 192.168.1.100)
  CONFIG_FILE         : Fichier credentials CIFS pour le montage NAS
  BORG_PASS_FILE      : Fichier contenant le mot de passe Borg (optionnel)
  DOCKER              : 1 = sauvegarde Docker activée, 0 = désactivée
  BACKUP_DOCKER       : Répertoire pour les backups Docker
  NAME_FOR_NOTIFY     : Nom utilisé dans les notifications SMS

Variables pour notifications Free Mobile (optionnel) :
  FREE_MOBILE_USER
  FREE_MOBILE_CODE_AUTH
  PHONE_NUMBER

Fonctionnalités principales :
  1. Vérifie que le script est lancé en root.
  2. Monte le NAS via CIFS si nécessaire, crée le point de montage.
  3. Installe automatiquement les paquets manquants :
     - borgbackup
     - cifs-utils
  4. Sauvegarde des conteneurs Docker (si activé) dans $BACKUP_DOCKER.
     - Export en .tar.gz
     - Suppression des archives >10 jours
  5. Sauvegarde complète via Borg :
     - Compression zlib
     - Exclusions par défaut : /proc, /dev, /run, /temp, /sys, caches utilisateurs, NAS monté, Docker temporaire
     - Prune automatique des sauvegardes anciennes (keep-daily=40)
  6. Démonte proprement le NAS à la fin.
  7. Envoie des notifications via Free Mobile en cas de succès ou d'erreur.

Exemple d'utilisation :
  sudo /usr/local/bin/backup
  sudo /usr/local/bin/backup -h

Logs :
  Toutes les actions sont loggées dans /var/log/backup.log

Notes :
  - Configurez correctement NAS_SERVER et CONFIG_FILE pour que le montage fonctionne.
  - DOCKER=1 active l'export des conteneurs Docker.
  - Le mot de passe Borg peut être stocké dans BORG_PASS_FILE.
EOF
}


borg_inst() {
    if dpkg -l | grep -q borgbackup; then
        log_message "Borg est déjà installé."
    else
        log_message "Borg n'est pas installé. Installation en cours..."
        apt-get update -y
        apt-get install borgbackup -y
    fi
}

mountcifs() {
    if dpkg -l | grep -q cifs-utils; then
        log_message "cifs-utils déjà installé"
    else
        log_message "Installation de cifs-utils"
        apt-get update -y
        apt-get install cifs-utils -y
    fi
}

umount_NAS() {
    if mountpoint -q "$MOUNT_POINT"; then
        log_message "Démontage du NAS en cours."
        umount "$MOUNT_POINT" 2>/dev/null || true

        # Vérification du démontage
        if mountpoint -q "$MOUNT_POINT"; then
            log_message "Le démontage standard a échoué, tentative forcée."
            umount -fr "$MOUNT_POINT" 2>/dev/null || true
        fi

        if mountpoint -q "$MOUNT_POINT"; then
            umount_success=0
            send_sms_notification "[$NAME_FOR_NOTIFY] /!\\ Problème lors du démontage du NAS."
            log_message "Démontage : échec"
        else
            umount_success=1
            send_sms_notification "[$NAME_FOR_NOTIFY] Le NAS a bien été démonté."
            log_message "Démontage : OK"
        fi
    else
        log_message "Point de montage $MOUNT_POINT non monté, rien à démonter."
    fi
}

# backup_docker : export des conteneurs en .tar.gz
backup_docker() {
    local rc=0
    local error=0

    if [ "${DOCKER:-0}" -ne 1 ]; then
        log_message "Aucune sauvegarde Docker demandée"
        return 10
    fi

    # Crée le dossier si besoin
    if [ ! -d "$BACKUP_DOCKER" ]; then
        mkdir -p "$BACKUP_DOCKER"
        log_message "Création du dossier de sauvegarde Docker : $BACKUP_DOCKER"
    fi

    # Vérifie la présence de docker
    if ! command -v docker >/dev/null 2>&1 || ! docker info >/dev/null 2>&1; then
        log_message "Docker n'est pas installé ou le daemon n'est pas accessible - Skip"
        return 1
    fi

    # Récupération des conteneurs
    mapfile -t containers < <(docker ps -q)
    local total=${#containers[@]}
    local count=0

    if [ "$total" -eq 0 ]; then
        log_message "Aucun conteneur Docker en cours — rien à exporter"
        echo "ℹ️ Aucun conteneur Docker à exporter"
    else
        for id in "${containers[@]}"; do
            count=$((count + 1))
            [ -n "$id" ] || continue

            local name
            name="$(docker inspect --format='{{.Name}}' "$id" 2>/dev/null || true)"
            name="${name#/}"
            [ -n "$name" ] || name="$id"

            local outfile="$BACKUP_DOCKER/${name}.tar.gz"
            log_message "Export de $name ($id)"
            echo "[$count/$total] Export de $name..."

            if docker export "$id" | gzip -9 >"$outfile"; then
                log_message "Export de $name OK"
                echo "[$count/$total] ✅ $name exporté"
            else
                log_message "Problème lors de l'export de $name"
                echo "[$count/$total] ❌ $name erreur"
                error=2
            fi
        done
    fi

    # Suppression des anciennes sauvegardes (>10 jours) — safe avec -print0 + xargs -0
    if ! find "$BACKUP_DOCKER" -maxdepth 1 -type f -mtime +10 -print0 | xargs -0 -r rm -f 2>/dev/null; then
        log_message "Erreur suppression des anciennes archives Docker"
        error=3
    fi

    if [ "$error" -ne 0 ]; then
        rc=$error
    else
        rc=0
    fi

    return $rc
}

return_backup_docker() {
    local RET=${1:-$?}
    case $RET in
        0)
            echo "✅ Sauvegarde Docker terminée avec succès"
            log_message "✅ Sauvegarde Docker terminée avec succès"
            send_sms_notification "[$NAME_FOR_NOTIFY] Sauvegarde Docker terminée avec succès"
            backup_docker_flag=1
            ;;
        1)
            echo "⚠️ Docker n’est pas installé ou le daemon n’est pas accessible"
            log_message "⚠️ Docker n’est pas installé ou le daemon n’est pas accessible"
            send_sms_notification "[$NAME_FOR_NOTIFY] Docker n’est pas installé ou le daemon n’est pas accessible"
            ;;
        2)
            echo "❌ Problème pendant l’export d’un conteneur Docker"
            log_message "❌ Problème pendant l’export d’un conteneur Docker"
            send_sms_notification "[$NAME_FOR_NOTIFY] Problème pendant l’export d’un conteneur Docker"
            ;;
        3)
            echo "⚠️ Problème lors de la suppression des anciens backups Docker"
            log_message "⚠️ Problème lors de la suppression des anciens backups Docker"
            send_sms_notification "[$NAME_FOR_NOTIFY] Problème lors de la suppression des anciens backups Docker"
            ;;
        10)
            echo "ℹ️ Pas de sauvegarde Docker demandée"
            log_message "ℹ️ Pas de sauvegarde Docker demandée"
            ;;
        *)
            echo "❌ Code inconnu : $RET"
            log_message "❌ Code inconnu : $RET"
            send_sms_notification "[$NAME_FOR_NOTIFY] Code inconnu Docker : $RET"
            ;;
    esac
}

#######################
# Début du script
#######################

# Analyse des options
while getopts ":h?" opt; do
    case $opt in
        h|\?)
            SHOW_HELP=true
            ;;
    esac
done

if [ "$SHOW_HELP" = true ]; then
    show_help
    exit 0
fi

log_message "=== Début sauvegarde [$NAME_FOR_NOTIFY] ==="

# Montage NAS si nécessaire
if ! mountpoint -q "$MOUNT_POINT"; then
    log_message "Vérification et installation éventuelle de cifs-utils"
    mountcifs

    if [ -z "$NAS_SERVER" ]; then
        log_message "NAS_SERVER non configuré. Abandon."
        send_sms_notification "[$NAME_FOR_NOTIFY] Échec : NAS_SERVER non configuré"
        exit 3
    fi

    log_message "Montage du NAS en cours vers $MOUNT_POINT"
    mkdir -p "$MOUNT_POINT"
    if mount -t cifs -o credentials="$CONFIG_FILE" "//${NAS_SERVER}/Backup/${NAME_FOR_NOTIFY}" "$MOUNT_POINT"; then
        log_message "Montage CIFS OK"
        mount_success=1
    else
        log_message "Erreur lors du montage CIFS (mount) — Vérifier CONFIG_FILE et NAS_SERVER"
        mount_success=0
    fi
else
    log_message "Point de montage $MOUNT_POINT déjà monté"
    mount_success=1
fi

# Lancer la sauvegarde Docker (si demandé) — on lève d'abord un retour capturé
if [ "${DOCKER:-0}" -eq 1 ]; then
    if RET_DOCKER=$(backup_docker 2>&1); then
        return_backup_docker 0
    else
        # récupération du code retour réel si possible
        RET_CODE=${RET_CODE:-$?}
        # fallback : si $? n'est pas fiable on assume échec
        return_backup_docker ${RET_CODE:-2}
    fi
else
    return_backup_docker 10
fi

# Si montage OK, exécuter Borg
if mountpoint -q "$MOUNT_POINT"; then
    log_message "Démarrage de la sauvegarde avec Borg Backup."
    borg_inst

    # Exclusions liées à Docker si activé
    if [ "${DOCKER:-0}" -eq 1 ] && command -v docker >/dev/null 2>&1; then
        for id in $(docker ps -q); do
            EXCLUDES="$EXCLUDES --exclude '/var/lib/docker/containers/$id/*'"
        done
        EXCLUDES="$EXCLUDES --exclude '/var/lib/docker/containers/*/*-json.log'"
        EXCLUDES="$EXCLUDES --exclude '/var/lib/docker/tmp/*'"
        EXCLUDES="$EXCLUDES --exclude '/var/lib/docker/overlay2/*/diff/tmp/*'"
    fi

    # Commande borg create (on s'assure que DEST_DIR existe)
    mkdir -p "$DEST_DIR"
    export BORG_PASSPHRASE
    set +e
    borg create -s -p --compression zlib "$DEST_DIR::$(date +"%Y%m%d%H%M%S")" "$SOURCE_DIR" \
        --exclude '/proc' \
        --exclude '/dev' \
        --exclude '/run' \
        --exclude '/temp' \
        --exclude "$MOUNT_POINT" \
        --exclude '/sys' \
        --exclude-caches \
        --exclude '/home/*/.cache/*' \
        --exclude '/mnt/nas' \
        $EXCLUDES
    RET_BORG=$?
    set -e

    if [ $RET_BORG -eq 0 ]; then
        backup_success=1
        log_message "Borg : sauvegarde OK"
        send_sms_notification "[$NAME_FOR_NOTIFY] Sauvegarde Borg terminée avec succès."
    else
        backup_success=0
        log_message "Borg : erreur lors de la sauvegarde (code $RET_BORG)"
        send_sms_notification "[$NAME_FOR_NOTIFY] Échec Borg : code $RET_BORG"
    fi

    # Prune — suppression des sauvegardes anciennes (ex: keep-daily=40)
    set +e
    borg prune "$DEST_DIR" --keep-daily=40
    if [ $? -ne 0 ]; then
        log_message "Prune Borg : erreur"
    else
        log_message "Prune Borg : OK"
    fi
    set -e
else
    log_message "Point de montage indisponible, skip Borg"
fi

# Démonter le NAS (fonctions gère l'envoi de notification sur échec/OK)
umount_NAS

# Résumé final / notification
if [ "$backup_docker_flag" -eq 1 ]; then
    send_sms_notification "[$NAME_FOR_NOTIFY] Sauvegarde Docker terminée."
fi

if [ "$backup_success" -eq 1 ]; then
    send_sms_notification "[$NAME_FOR_NOTIFY] Sauvegarde Borg terminée."
elif [ "$mount_success" -eq 1 ] && [ "$backup_success" -eq 0 ]; then
    send_sms_notification "[$NAME_FOR_NOTIFY] Échec de la sauvegarde Borg (voir logs)."
else
    send_sms_notification "[$NAME_FOR_NOTIFY] Sauvegarde non effectuée : impossible de monter le NAS."
fi

log_message "=== Fin sauvegarde [$NAME_FOR_NOTIFY] ==="
